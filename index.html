<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Comms Checker</title>
  <style>
    :root{
      --bg:#ffffff;
      --card:#ffffff;
      --line:#e5e7eb;
      --text:#111827;
      --muted:#6b7280;
      --green:#16a34a;
      --yellow:#d97706;
      --red:#dc2626;
      --blue:#2563eb;
      --shadow:0 1px 2px rgba(0,0,0,.06);
      --shadow2:0 8px 24px rgba(0,0,0,.06);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px; margin:0 auto; padding:24px 16px 56px;}
    h1{font-size:26px; margin:0 0 8px;}
    .sub{color:var(--muted); line-height:1.6; margin:0 0 16px;}

    .card{background:var(--card); border:1px solid var(--line); border-radius:14px; padding:16px; margin:12px 0; box-shadow:var(--shadow);}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center;}
    label{font-size:13px; color:var(--muted)}

    select, textarea{
      border-radius:12px;
      border:1px solid var(--line);
      background:#ffffff;
      color:var(--text);
      padding:10px 12px;
      font-size:14px;
    }
    select{min-width:260px}
    textarea{width:100%; min-height:220px; resize:vertical; line-height:1.6}

    button{
      border-radius:12px;
      border:1px solid #6b7280;
      background:#6b7280;
      color:#ffffff;
      padding:10px 14px;
      font-size:14px;
      font-weight:800;
      cursor:pointer;
      box-shadow:var(--shadow);
    }
    button:hover{background:#4b5563; border-color:#4b5563}
    button:disabled{opacity:.55; cursor:not-allowed}

    .hint{color:var(--muted); font-size:12px; margin-top:6px}
    .meta{display:flex; align-items:center; gap:10px; flex-wrap:wrap}

    .pill{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; color:var(--muted); background:#ffffff}
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block}
    .g{background:var(--green)}
    .y{background:var(--yellow)}
    .r{background:var(--red)}

    details{border:1px solid var(--line); border-radius:12px; padding:12px; background:#f9fafb}
    summary{cursor:pointer; user-select:none; font-weight:800}
    summary::-webkit-details-marker{display:none}

    .counter{font-size:12px; color:var(--muted)}

    .result{display:none}
    .resultTop{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    .badge{display:inline-flex; align-items:center; gap:8px; border-radius:999px; padding:6px 10px; font-size:12px; font-weight:900; border:1px solid var(--line); background:#ffffff}
    .bGreen{border-color:rgba(22,163,74,.35)}
    .bYellow{border-color:rgba(217,119,6,.35)}
    .bRed{border-color:rgba(220,38,38,.35)}

    .grid{display:grid; grid-template-columns:1fr; gap:12px}
    @media (min-width:900px){ .grid{grid-template-columns:1fr 1fr} }

    .sectionTitle{font-weight:900; margin:0 0 8px}
    ul{margin:0; padding-left:18px}
    li{margin:6px 0}

    .kpi{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px}
    .kpi .pill{color:var(--text); background:#f9fafb}

    /* Result - Stage 1 / Stage 2 */
    .stage1{display:flex; gap:12px; align-items:stretch; justify-content:space-between; margin-top:12px}
    .stage1Main{flex:1; border:1px solid var(--line); border-radius:14px; padding:12px 14px; background:#ffffff; box-shadow:var(--shadow)}
    .stage1Label{font-size:12px; font-weight:900; color:var(--muted); margin-bottom:6px}
    .stage1Text{font-size:13px; line-height:1.5}
    .stage1Side{display:flex; gap:10px}
    .mini{width:140px; border:1px solid var(--line); border-radius:14px; padding:12px; background:#ffffff; box-shadow:var(--shadow); display:flex; flex-direction:column; justify-content:center}
    .miniTitle{font-size:12px; color:var(--muted); font-weight:800}
    .miniValue{font-size:20px; font-weight:900; margin-top:4px}
    .topFix{margin-top:10px; border:1px solid var(--line); border-radius:14px; padding:12px 14px; background:#ffffff; box-shadow:var(--shadow)}
    .topFixTitle{font-size:13px; font-weight:900; margin-bottom:8px}
    .topFixList{margin:0; padding-left:18px}
    .topFixList li{margin:6px 0}
    .topFixNote{margin-top:8px; font-size:12px}
    .toggleRow{display:flex; justify-content:flex-end; margin-top:10px}
    .toggle{font-size:12px; color:var(--muted); display:flex; gap:8px; align-items:center; user-select:none}
    .toggle input{accent-color:#111827}
    @media (max-width: 720px){
      .stage1{flex-direction:column}
      .stage1Side{flex-direction:row}
      .mini{flex:1; width:auto}
    }

    .hr{height:1px; background:var(--line); margin:14px 0}

    .footnote{color:var(--muted); font-size:12px; margin-top:10px}
    .muted{color:var(--muted)}

    .legend{display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start}
    .legendItem{border:1px solid var(--line); border-radius:12px; padding:8px 10px; background:#ffffff; min-width:220px; box-shadow:var(--shadow)}
    .legendTop{font-size:12px; font-weight:900}
    .legendSub{font-size:12px; color:var(--muted); margin-top:4px; line-height:1.4}
  
    /* Collapsible common results */
    details.commonDetails{border:1px solid var(--line); border-radius:14px; padding:0; background:#fff;}
    details.commonDetails > summary.sectionTitle{padding:14px 16px; margin:0; cursor:pointer; list-style:none; display:flex; align-items:center; justify-content:space-between;}
    details.commonDetails > summary.sectionTitle::-webkit-details-marker{display:none;}
details.commonDetails .detailsBody{padding:0 16px 12px;}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Comms Checker</h1>
    <p class="sub">카테고리(판단 관점) 기준으로 커뮤니케이션 문장을 점검합니다. 결과는 ‘정답/오답’이 아니라, 판단자가 어디에서 멈추거나 오해할 가능성이 높은지에 대한 신호입니다.<br>보도자료·사내공지·보고서 등 업무용 글쓰기에서 오해가 발생할 수 있는 지점을 사전에 점검하는 커뮤니케이션 판단 보조 도구입니다.</p>

    <section class="card" aria-label="안내">
      <div class="sectionTitle">안내</div>
      <p class="muted" style="margin:0 0 12px">
        이 툴은 문장을 수정하거나 대신 작성하지 않습니다. 입력된 문장을 체크리스트 방식으로 점검합니다. 최종 판단과 수정은 작성자의 몫입니다.
      </p>

      <details>
        <summary>사용 방법 (접기/더보기)</summary>
        <ol class="muted" style="margin:10px 0 0; padding-left:18px; line-height:1.7">
          <li>상단에서 카테고리를 선택합니다.</li>
          <li>점검할 글(최대 1,200자)을 입력합니다.</li>
          <li>점검하기를 누르면 하단에 <b>공통 점검</b>과 <b>카테고리 점검</b> 결과가 나옵니다.</li>
        </ol>
      </details>

      <div style="margin-top:14px">
        <label for="category">카테고리 선택 (판단 관점)</label>
        <div class="meta" style="margin-top:6px">
          <select id="category">
            <option value="press_release">Press Release (외부/기자)</option>
            <option value="c_level">C-level 메시지 (리더/조직)</option>
            <option value="internal_notice">내부 안내 (구성원/실무자)</option>
            <option value="work_report">업무 보고 (상사/의사결정자)</option>
            <option value="sns">SNS 글 (대중/팔로워)</option>
          </select>

          <div class="legend" aria-label="판단 리스크 신호">
            <div class="legendItem">
              <div class="legendTop">🟢 의미가 비교적 명확함</div>
              <div class="legendSub">(오해의 여지가 적고 쉽게 이해됨)</div>
            </div>
            <div class="legendItem">
              <div class="legendTop">🟡 오해의 여지 있음</div>
              <div class="legendSub">(읽는 사람에 따라 해석이 달라질 수 있음)</div>
            </div>
            <div class="legendItem">
              <div class="legendTop">🔴 오해 가능성 큼</div>
              <div class="legendSub">(맥락·근거 보완이 필요함)</div>
            </div>
          </div>
        </div>
        <div class="hint" id="categoryHint"></div>
        <div class="hint" style="margin-top:8px">
          선택한 카테고리의 판단자에게 오해의 여지가 있거나 판단의 어려움을 겪을 가능성이 있는지를 보여주는 신호입니다.
        </div>
      </div>
    </section>

    <section class="card" aria-label="입력">
      <div class="sectionTitle">점검할 문장 입력</div>
      <label for="inputText">텍스트</label>
      <textarea id="inputText" placeholder="여기에 점검할 문장을 붙여넣으세요."></textarea>
      <div class="row" style="justify-content:space-between; margin-top:10px">
        <div class="counter" id="counter">0 / 1200</div>
        <button id="checkBtn" type="button" onclick="runCheck()">점검하기</button>
      </div>
      <div class="footnote">권장: 긴 문서는 핵심 문단/섹션 단위로 나눠 점검하세요.</div>
    </section>

    <section class="card result" id="resultWrap" aria-label="결과">
      <div class="sectionTitle">점검 결과</div>

      <div class="resultTop">
        <span class="badge" id="verdictBadge">-</span>
        <div class="muted" id="verdictMsg"></div>
      </div>

      <div class="stage1">
        <div class="stage1Main">
          <div class="stage1Label">1단계 요약</div>
          <div class="stage1Text" id="stage1Text">-</div>
        </div>
        <div class="stage1Side">
          <div class="mini">
            <div class="miniTitle">공통 보완</div>
            <div class="miniValue" id="commonNeedCount">-</div>
          </div>
          <div class="mini">
            <div class="miniTitle">카테고리 보완</div>
            <div class="miniValue" id="catNeedCount">-</div>
          </div>
        </div>
      </div>

      <div class="topFix">
        <div class="topFixTitle">우선 보완 TOP 3</div>
        <ol id="topFixList" class="topFixList"></ol>
        <div class="topFixNote muted">* 초록 항목은 기본적으로 숨기고, 보완이 필요한 항목(노랑/빨강)만 우선 보여줍니다.</div>
      </div>
<div class="hr"></div>

      <div class="grid">
        
        <details class="commonDetails">
          <summary class="sectionTitle">▶ 공통 점검 결과 (접기/더보기)</summary>
          <div class="detailsBody">
            <ul id="commonList"></ul>
          </div>
        </details>
        <details class="commonDetails">
          <summary class="sectionTitle">▶ 카테고리 점검 결과 (접기/더보기)</summary>
          <div class="detailsBody">
            <ul id="categoryList"></ul>
          </div>
        </details>
      </div>

      <div class="hr"></div>
      <div class="footnote">이 결과는 규칙 기반 점검입니다. 최종 판단과 수정은 작성자의 몫입니다.</div>
    </section>

  </div>

  <script>
    const MAX_LEN = 1200;

    const categoryMeta = {
      press_release: {
        label: "Press Release",
        hint: "외부 독자/기자 관점에서 기사화 가능성과 오해 소지를 점검합니다."
      },
      c_level: {
        label: "C-level 메시지",
        hint: "리더의 해석과 방향(기준)이 문장에 드러나는지 점검합니다."
      },
      internal_notice: {
        label: "내부 안내",
        hint: "구성원이 읽고 바로 이해·행동할 수 있는지 점검합니다."
      },
      work_report: {
        label: "업무 보고",
        hint: "의사결정에 필요한 정보(결론/근거/요청)가 정리되어 있는지 점검합니다."
      },
      sns: {
        label: "SNS 글",
        hint: "짧은 문장 안에서 맥락 부족, 단정 표현, 오해 가능성을 점검합니다."
      }
    };

    function norm(t){
      return (t || "").replace(/\r/g, "");
    }

    function splitLines(t){
      return norm(t).split("\n").map(s => s.trim()).filter(Boolean);
    }

    function hasAny(t, arr){
      return arr.some(w => t.includes(w));
    }

    function countMatches(t, re){
      const m = t.match(re);
      return m ? m.length : 0;
    }

    function extractDates(t){
      const out = [];
      const re1 = /\b(20\d{2})[.\/-](\d{1,2})[.\/-](\d{1,2})\b/g;
      const re2 = /(\d{1,2})\s*월\s*(\d{1,2})\s*일/g;
      let m;
      while((m = re1.exec(t)) !== null) out.push(m[0]);
      while((m = re2.exec(t)) !== null) out.push(m[0]);
      return [...new Set(out)];
    }

    function extractContacts(t){
      const emails = [...new Set((t.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi) || []))];
      const phones = [...new Set((t.match(/\b(\d{2,4}[- ]?\d{3,4}[- ]?\d{4})\b/g) || []))];
      return { emails, phones };
    }

    function makeItem(title, level, msg){
      return { title, level, msg };
    }

    function summarize(items){
      const g = items.filter(i => i.level === "g").length;
      const y = items.filter(i => i.level === "y").length;
      const r = items.filter(i => i.level === "r").length;
      return { g, y, r, total: items.length };
    }

    function verdictFrom(allItems){
      const s = summarize(allItems);
      // 간단하고 안정적인 규칙
      if(s.r >= 2) return "RED";
      if(s.r === 1) return "YELLOW";
      if(s.y >= 3) return "YELLOW";
      return "GREEN";
    }

    function commonChecks(text){
      const t = norm(text);
      const lines = splitLines(text);
      const items = [];

      // 1) 주체/대상
      const hasSubject = hasAny(t, ["우리", "당사", "회사", "팀", "조직", "본사", "고객", "구성원", "여러분", "~님"]);
      items.push(makeItem(
        "주체/대상이 명확한가",
        hasSubject ? "g" : "y",
        hasSubject ? "주체/대상 단서가 있습니다." : "누가 말하고, 누가 대상인지가 흐릿할 수 있습니다. 주체/대상을 1번만이라도 명시하세요."
      ));

      // 2) 사실/해석 구분
      const hasNums = /\d/.test(t);
      const hasFactWords = hasAny(t, ["발표", "진행", "개최", "체결", "오픈", "입고", "변경", "도입", "확인", "일정"]);
      const hasInterpret = hasAny(t, ["의미", "강화", "시너지", "혁신", "가치", "선도", "차별화"]);
      let level = "g";
      if(hasInterpret && !hasFactWords && !hasNums) level = "r";
      else if(hasInterpret) level = "y";
      items.push(makeItem(
        "사실과 해석이 분리되는가",
        level,
        level === "g" ? "사실 단서가 있거나, 과도한 해석 표현이 두드러지지 않습니다." :
        (level === "y" ? "해석 표현이 섞여 있습니다. 사실(언제/무엇을/누가)을 먼저 두고, 해석은 뒤로 분리하면 안정적입니다." :
         "해석/평가 표현만 두드러집니다. 사실/근거를 먼저 제시하지 않으면 판단자가 멈출 가능성이 큽니다.")
      ));

      // 3) 장황함(분량/문단)
      const tooLong = t.length > 900 || lines.length >= 7;
      const midLong = t.length > 650 || lines.length >= 5;
      items.push(makeItem(
        "핵심이 앞에서 잡히는가(장황함)",
        tooLong ? "r" : (midLong ? "y" : "g"),
        tooLong ? "긴 문서로 인식될 수 있습니다. 핵심 결론/요청을 1~2문장으로 앞에 고정하고 문단을 쪼개세요." :
        (midLong ? "핵심이 분산될 수 있습니다. ‘결론 1줄 → 근거’ 순서로 압축하면 좋습니다." :
         "길이/문단 수가 과도하지 않습니다.")
      ));

      // 4) 연결어(논리 흐름)
      const hasConnect = hasAny(t, ["따라서","그러나","하지만","또한","특히","한편","때문에","반면","이에 따라"]);
      items.push(makeItem(
        "문단/문장 연결이 드러나는가",
        (!hasConnect && lines.length >= 4) ? "y" : "g",
        (!hasConnect && lines.length >= 4)
          ? "문단 사이 논리 관계가 숨을 수 있습니다. 연결어로 ‘왜 이 문장이 다음 문장으로 가는지’를 드러내세요."
          : "연결 흐름 단서가 있습니다."
      ));

      // 5) 근거/출처/수치(필요 시)
      const hasEvidence = /(\d+(\.\d+)?%|\d{1,3}(,\d{3})+|\d+명|\d+건|\d+회|\d+원)/.test(t) || hasAny(t, ["근거","데이터","수치","출처","참고","링크"]);
      items.push(makeItem(
        "근거 단서(수치/사실/링크)가 있는가",
        hasEvidence ? "g" : "y",
        hasEvidence ? "근거 단서가 있습니다." : "근거 단서가 약합니다. 필요한 경우 수치/일정/링크 중 1개만이라도 붙이면 설득력이 안정됩니다."
      ));

      return items;
    }

    function categoryChecks(category, text){
      const t = norm(text);
      const lines = splitLines(text);
      const items = [];

      if(category === "internal_notice"){
        const hasPurpose = hasAny(t, ["안내드립니다","공지드립니다","공유드립니다","아래와 같이","다음 사항"]) || hasAny(lines[0] || "", ["안내","공지","[안내]","[공지]"]);
        items.push(makeItem(
          "용건(첫 화면) 명시",
          hasPurpose ? "g" : "y",
          hasPurpose ? "용건을 알리는 표현이 감지됩니다." : "첫 문단에서 용건이 뚜렷하지 않습니다. ‘무엇을 안내하는지’를 1문장으로 먼저 제시하세요."
        ));

        const hasTarget = hasAny(t, ["전 직원","전사","해당 부서","대상","각 팀","전 구성원"]);
        items.push(makeItem(
          "대상/범위",
          hasTarget ? "g" : "y",
          hasTarget ? "대상/범위 단서가 보입니다." : "누가 적용 대상인지가 흐릿합니다. ‘대상/범위’를 1줄로 분리하세요."
        ));

        const hasSteps = hasAny(t, ["신청","작성","제출","확인","다운로드","참여"]) && hasAny(t, ["방법","경로","절차","→","1.","2.","•","- "]);
        items.push(makeItem(
          "행동/절차(무엇을 어떻게)",
          hasSteps ? "g" : "y",
          hasSteps ? "절차/경로 신호(번호/불릿/경로)가 보입니다." : "행동/절차가 문장 속에 묻힐 수 있습니다. ‘경로/방법’을 번호나 불릿으로 분리하세요."
        ));

        const dates = extractDates(t);
        const hasDeadline = dates.length > 0 || hasAny(t, ["까지","마감","기한","기간"]);
        items.push(makeItem(
          "기한/시점",
          hasDeadline ? "g" : "y",
          hasDeadline ? "기한/시점 단서가 보입니다." : "기한/시점 단서가 약합니다. 필요한 경우 ‘언제까지/언제부터’를 명시하세요."
        ));

        const hasException = hasAny(t, ["단,","다만","유의","주의","※","참고:","예외"]);
        items.push(makeItem(
          "주의/예외(필요 시) 분리",
          hasException ? "g" : "y",
          hasException ? "주의/예외 신호가 있습니다." : "주의/예외가 필요한 글이라면, ‘단/유의사항’을 별도 라인으로 분리하세요."
        ));

        const c = extractContacts(t);
        const hasContact = hasAny(t, ["문의","담당"]) || c.emails.length > 0 || c.phones.length > 0;
        items.push(makeItem(
          "문의 경로",
          hasContact ? "g" : "y",
          hasContact ? "문의/담당 단서가 있습니다." : "문의 경로가 없으면 질문이 늘 수 있습니다. 필요 시 ‘문의: 담당/메일’ 1줄을 추가하세요."
        ));
      }

      if(category === "work_report"){
        const head = lines[0] || "";
        const hasTag = /^\s*\[(공유|요청|결정|보고)\]/.test(head) || hasAny(head, ["공유","요청","결정","보고"]);
        items.push(makeItem(
          "보고 유형(공유/요청/결정) 명시",
          hasTag ? "g" : "y",
          hasTag ? "보고 성격 단서가 초반에 보입니다." : "초반에 보고 성격이 불명확합니다. 제목/첫줄에 [공유]/[요청]/[결정] 형태로 고정해 보세요."
        ));

        const firstBlock = lines.slice(0,5).join(" ");
        const hasAskOrConcl = hasAny(firstBlock, ["요청","확인 부탁","결정","공유","보고드립니다","결재","검토 부탁","승인"]);
        items.push(makeItem(
          "결론/요청 선배치(초반)",
          hasAskOrConcl ? "g" : "y",
          hasAskOrConcl ? "초반에 결론/요청 단서가 있습니다." : "결론/요청이 초반에 보이지 않습니다. ‘결론 1줄 → 근거’ 순으로 재배치하세요."
        ));

        const hasEvidence = /(\d+(\.\d+)?%|\d{1,3}(,\d{3})+|\d+명|\d+건|\d+회|\d+원)/.test(t) || hasAny(t, ["현황","근거","데이터","수치","일정","비용"]);
        items.push(makeItem(
          "근거/현황(최소 단서)",
          hasEvidence ? "g" : "y",
          hasEvidence ? "근거/현황 단서가 있습니다." : "결론을 뒷받침하는 근거 단서가 약합니다. 수치/일정/현황 중 1개라도 붙이면 판단이 빨라집니다."
        ));

        const hasOptions = hasAny(t, ["옵션","안","대안","선택지","A안","B안"]) || countMatches(t, /\b(1\)|2\)|3\)|①|②|③)\b/g) >= 2;
        items.push(makeItem(
          "결정 포인트(옵션/요청) 분리",
          hasOptions || hasAny(t,["결정","확정","승인","의견"]) ? "g" : "y",
          (hasOptions || hasAny(t,["결정","확정","승인","의견"])) ? "결정/요청 단서가 있습니다." : "결정해야 할 포인트가 문장 속에 묻힐 수 있습니다. ‘결정 요청 1줄’을 분리하세요."
        ));

        const hasRisk = hasAny(t, ["리스크","이슈","우려","문제","가능성","법","규정","컴플라이언스"]);
        items.push(makeItem(
          "리스크/주의사항 노출",
          hasRisk ? "g" : "y",
          hasRisk ? "리스크/주의 단서가 보입니다." : "리스크/주의사항이 없다면 괜찮지만, 존재한다면 1줄로 먼저 노출해 결재자를 안전하게 만드세요."
        ));
      }

      if(category === "c_level"){
        const hasFrame = hasAny(t, ["환경","변화","전환","불확실","시장","고객","AI","규제","리스크","기회","구조"]);
        items.push(makeItem(
          "상황 해석(맥락) 제시",
          hasFrame ? "g" : "y",
          hasFrame ? "맥락 단서가 있습니다." : "상황 해석이 약하면 메시지가 ‘의견’으로 들릴 수 있습니다. 변화/리스크/기회를 1문장으로 고정하세요."
        ));

        const hasRole = hasAny(t, ["역할","방향","원칙","기준","우리는","조직","팀","책임","정의"]);
        items.push(makeItem(
          "조직의 역할/방향 고정",
          hasRole ? "g" : "y",
          hasRole ? "역할/방향 단서가 보입니다." : "조직의 역할/방향이 드러나지 않으면 메시지가 분산됩니다. ‘우리는 무엇을 기준으로 움직인다’를 1문장으로 넣으세요."
        ));

        const hasDirective = hasAny(t, ["지시","반드시","즉시","해라","해야 한다","필수"]);
        items.push(makeItem(
          "지시형 표현 과다 여부",
          hasDirective ? "y" : "g",
          hasDirective ? "지시형 표현이 섞여 있습니다. ‘실행 지시’보다 ‘방향/기준 고정’ 언어로 치환하면 C레벨 톤이 선명해집니다." : "지시형 표현이 과도하지 않습니다."
        ));

        const vagueCount = countMatches(t, /(의미|강화|시너지|확대|고도화|최적화|혁신|선도|차별화|가치)/g);
        items.push(makeItem(
          "추상어(의미/강화/시너지 등) 밀도",
          vagueCount >= 3 ? "r" : (vagueCount >= 1 ? "y" : "g"),
          vagueCount >= 3 ? "추상어 밀도가 높습니다. 판단 기준이 흐려질 수 있으니, 1개만 남기고 근거/사례로 치환하세요." :
          (vagueCount >= 1 ? "추상어가 일부 보입니다. 근거(사실/사례)와 붙여 쓰면 안정됩니다." : "추상어 밀도가 낮습니다.")
        ));

        const hasClosure = hasAny(t, ["이 기준으로","이를 바탕으로","앞으로도","향후","우리는 계속"]);
        items.push(makeItem(
          "결론(기준/의미)의 마무리",
          hasClosure ? "g" : "y",
          hasClosure ? "마무리 결론 단서가 있습니다." : "마무리에서 ‘무엇을 기준으로 이어갈지’ 1문장을 넣으면 메시지가 고정됩니다."
        ));
      }

      if(category === "press_release"){
        const whyNow = hasAny(t, ["오늘","이번","최근","앞두고","발표","개최","착수","출시","오픈","체결","진행"]);
        items.push(makeItem(
          "Why now(왜 지금인가)",
          whyNow ? "g" : "y",
          whyNow ? "시점/계기 단서가 보입니다." : "Why now가 약합니다. 발표/행사/도입 등 ‘지금의 계기’를 1문장으로 명시하세요."
        ));

        const hasWhoWhat = hasAny(t, ["맨파워","당사","회사","협회","기관","고객","파트너"]) && hasAny(t, ["발표","진행","개최","체결","오픈","선정","수상"]);
        items.push(makeItem(
          "누가/무엇을 했는가(기사 뼈대)",
          hasWhoWhat ? "g" : "y",
          hasWhoWhat ? "기사 뼈대 단서가 있습니다." : "누가 무엇을 했는지 뼈대가 흐릿합니다. ‘주체-행동-대상’을 첫 문단에 고정하세요."
        ));

        const hasEvidence = /(\d+(\.\d+)?%|\d{1,3}(,\d{3})+|\d+명|\d+건|\d+회|\d+원)/.test(t) || extractDates(t).length > 0;
        items.push(makeItem(
          "근거(수치/일정) 포함",
          hasEvidence ? "g" : "y",
          hasEvidence ? "근거 단서(수치/일정)가 있습니다." : "근거 단서가 약합니다. 날짜/규모/횟수 중 1개라도 넣으면 기사화가 쉬워집니다."
        ));

        const hasVaguePromo = countMatches(t, /(의미|강화|시너지|혁신|선도|차별화|가치)/g) >= 2;
        items.push(makeItem(
          "홍보성 추상 표현 과다 여부",
          hasVaguePromo ? "y" : "g",
          hasVaguePromo ? "추상 홍보 표현이 겹칠 수 있습니다. 1개만 남기고 근거/맥락으로 치환하세요." : "추상 홍보 표현이 과도하지 않습니다."
        ));
        const hasQuote = /[“”"]/.test(text) || hasAny(t, ["말했다","밝혔다","설명했다"]);
        items.push(makeItem(
          "인용/발언(필요 시)",
          hasQuote ? "g" : "y",
          hasQuote ? "인용/발언 단서가 보입니다." : "기자 관점에서 ‘의미’를 잡아줄 인용이 필요한 유형이라면 1개만 추가해도 기사 완성도가 올라갑니다."
        ));
      }

      if(category === "sns"){
        const shortEnough = text.length <= 600 && lines.length <= 6;
        items.push(makeItem(
          "한 번에 읽히는 길이",
          shortEnough ? "g" : "y",
          shortEnough ? "길이가 과도하지 않습니다." : "SNS는 집중 시간이 짧습니다. 핵심 문장을 앞에 두고, 문장/줄 수를 줄이세요."
        ));

        const hasContext = hasAny(t, ["오늘","이번","최근","앞두고","발표","공유","안내"]) || extractDates(t).length > 0;
        items.push(makeItem(
          "맥락(상황/대상) 최소 포함",
          hasContext ? "g" : "y",
          hasContext ? "맥락 단서가 있습니다." : "맥락이 부족하면 오해가 생깁니다. ‘지금/무슨 일/대상’을 한 줄로 보강하세요."
        ));

        const hasCTA = hasAny(t, ["링크","클릭","확인","신청","자세히","프로필","첨부"]) || /https?:\/\//.test(t);
        items.push(makeItem(
          "의도(CTA) 명시",
          hasCTA ? "g" : "y",
          hasCTA ? "CTA 단서가 있습니다." : "의도가 안내/유도라면 CTA(확인/링크/첨부)를 명시하세요."
        ));

        const hasOverClaim = hasAny(t, ["무조건","절대","완벽","최고","역대","충격","대박"]);
        items.push(makeItem(
          "단정/과잉 확신 표현",
          hasOverClaim ? "y" : "g",
          hasOverClaim ? "단정/과잉 확신 표현이 오해를 부를 수 있습니다. 표현 강도를 낮추면 안전합니다." : "표현 강도가 과도하지 않습니다."
        ));

        const vagueCount = countMatches(t, /(의미|강화|시너지|혁신|선도|차별화|가치)/g);
        items.push(makeItem(
          "추상어 밀도",
          vagueCount >= 2 ? "y" : "g",
          vagueCount >= 2 ? "추상어가 반복되면 메시지가 흐려집니다. 1개만 남기고 사실/사례로 치환하세요." : "추상어 밀도가 과도하지 않습니다."
        ));
      }

      return items;
    }

    function renderList(el, items){
      const viewItems = Array.isArray(items) ? items : [];
      el.innerHTML = "";
      if(viewItems.length === 0){
        const li = document.createElement("li");
        li.textContent = "해당 항목 없음";
        el.appendChild(li);
        return;
      }
      viewItems.forEach(it => {
        const li = document.createElement("li");
        const icon = it.level === "g" ? "🟢" : (it.level === "y" ? "🟡" : "🔴");
        li.innerHTML = `<b>${icon} ${escapeHtml(it.title)}</b><div class="muted" style="margin-top:4px">${escapeHtml(it.msg)}</div>`;
        el.appendChild(li);
      });
    }

    function renderKpi(el, allItems){
      const s = summarize(allItems);
      el.innerHTML = "";
      const mk = (dotCls, label, n) => {
        const span = document.createElement("span");
        span.className = "pill";
        span.innerHTML = `<span class="dot ${dotCls}"></span> ${label}: <b>${n}</b>`;
        return span;
      };
      el.appendChild(mk("g","🟢", s.g));
      el.appendChild(mk("y","🟡", s.y));
      el.appendChild(mk("r","🔴", s.r));
    }

    // UI 바인딩
    function escapeHtml(str){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    const categoryEl = document.getElementById("category");
    const hintEl = document.getElementById("categoryHint");
    const textEl = document.getElementById("inputText");
    const counterEl = document.getElementById("counter");
    const btnEl = document.getElementById("checkBtn");

    function setHint(){
      const c = categoryEl.value;
      hintEl.textContent = categoryMeta[c].hint;
    }
    categoryEl.addEventListener("change", setHint);
    setHint();

    function updateCounter(){
      let val = textEl.value;
      if(val.length > MAX_LEN){
        textEl.value = val.slice(0, MAX_LEN);
      }
      const len = textEl.value.length;
      counterEl.textContent = `${len} / ${MAX_LEN}`;
      btnEl.disabled = textEl.value.trim().length === 0;
    }
    textEl.addEventListener("input", updateCounter);
    updateCounter();

    function runCheck(){
      const category = categoryEl.value;
      const text = textEl.value.trim();
      if(!text){
        return;
      }

      const common = commonChecks(text);
      const cat = categoryChecks(category, text);
      const all = [...common, ...cat];
      const verdict = verdictFrom(all);

      const badge = document.getElementById("verdictBadge");
      const msg = document.getElementById("verdictMsg");
      const commonList = document.getElementById("commonList");
      const categoryList = document.getElementById("categoryList");

      const label = categoryMeta[category].label;

      // 상단 요약(신호)
      if(verdict === "GREEN"){
        badge.className = "badge bGreen";
        badge.textContent = "🟢 의미가 비교적 명확함";
        msg.textContent = `${label} 관점에서 오해의 여지가 적고 쉽게 이해될 가능성이 높습니다.`;
      }else if(verdict === "YELLOW"){
        badge.className = "badge bYellow";
        badge.textContent = "🟡 오해의 여지 있음";
        msg.textContent = `${label} 관점에서 일부 문장이 오해의 여지가 있습니다. 아래 항목을 우선 보완하세요.`;
      }else{
        badge.className = "badge bRed";
        badge.textContent = "🔴 오해 가능성 큼";
        msg.textContent = `${label} 관점에서 오해 가능성이 큽니다. 맥락·근거 보완이 필요합니다.`;
      }
      // 1단계 요약(보완 필요 수 + TOP3)
      const commonNeed = common.filter(i => i.level !== "g");
      const catNeed = cat.filter(i => i.level !== "g");

      document.getElementById("stage1Text").textContent =
        `선택한 카테고리의 판단자에게 오해의 여지가 있거나 판단의 어려움을 겪을 가능성이 있는지를 보여주는 신호입니다.`;

      document.getElementById("commonNeedCount").textContent = commonNeed.length;
      document.getElementById("catNeedCount").textContent = catNeed.length;

      // TOP 3 (🔴 우선, 그 다음 🟡)
      const rank = (lvl) => (lvl === "r" ? 0 : (lvl === "y" ? 1 : 2));
      const merged = [
        ...common.map(i => ({...i, _section:"공통"})),
        ...cat.map(i => ({...i, _section: label}))
      ].filter(i => i.level !== "g")
       .sort((a,b) => rank(a.level) - rank(b.level));

      const topFixEl = document.getElementById("topFixList");
      topFixEl.innerHTML = "";
      if(merged.length === 0){
        topFixEl.innerHTML = "<li>보완이 필요한 항목이 없습니다.</li>";
      }else{
        merged.slice(0,3).forEach(it => {
          const emoji = it.level === "y" ? "🟡" : "🔴";
          const li = document.createElement("li");
          li.innerHTML = `<b>${emoji} [${escapeHtml(it._section)}] ${escapeHtml(it.title)}</b><div class="muted" style="margin-top:4px">${escapeHtml(it.msg)}</div>`;
          topFixEl.appendChild(li);
        });
      }

      // 리스트 렌더
      renderList(commonList, common);
      renderList(categoryList, cat);

      // 결과 노출
      const wrap = document.getElementById("resultWrap");
      wrap.style.display = "block";
      wrap.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    window.runCheck = runCheck;

    // TODO (향후 AI 연결):
    // runCheck() 내부에서 evaluate() 대신 fetch('/api/check', ...)로 JSON을 받아
    // 같은 UI 렌더링 함수로 표시하면 구조 변경 없이 AI로 치환 가능합니다.
  </script>

</body>
</html>
 
